---
layout: post
title:  "마이크로서비스"
date:   2018-01-22 11:11:11
author: Reid
categories: 
---

아키텍쳐의 진화
(monolithic application의 문제)
(컴퓨팅 성능의 향상)
(도커의 출현)

마이크로서비스의 출현
(soa)-서비스의 크기가 작다, soa의 부분집합,soa에 비해 서비스의 독립성이 더 보장되나. ESB가 spof가 될 수 있음.
(간단한 소개)
(넷플릭스 수천개의 마이크로서비스의 결합체)

마이크로서비스의 특징
(한 기능에 한 서비스)
(독립적인 데이터 모델)
(독립적인 구현 기술)-어떤 통신 수단이던, 데이터 포맷이던 문제 없음
(독립적인 개발, 배포)-이것들이 어떤 결과로 이어질까?

왜 마이크로서비스인가
(기능 추가의 편의성)
(팀 단위 개발의 기능 향상)-서로 다른 언어,도구,라이브러리,플랫폼
(쉬운 유지 보수)-신입도 적응 빠름, 코드가 미치는 영향력이 국소적이기 때문에 부작용 염려가 적음.
(쉬운 확장)-필요한 서비스만 확장
(쉬운 테스트)-격리 테스트,퀄리티 유지
(쉬운 배포)-작은 수정 하나에도 전체 서비스를 업데이트해야 했던 과거
(쉬운 재사용)
(비용 절감)
(결국 빠른 반복)

마이크로서비스의 문제
(monolithic microservice 집합)-잘못하면 거미줄 지옥, 오히려 부하만 줌
(설계가 매우 중요)
(데이터가 분산되어 있기 때문에 일관성 유지하는 것이 중요)
(철학을 잘 따라야 함)

마이크로서비스의 철학-강력하게 유지되어야 함
(작은 서비스를 유지)-피자2판, 2주 재작성,하나에 한가지 기능!
(서비스의 독립성 보장)-별개 프로세스,단일책임원칙(문제 가능성을 줄이고, 빠른 대처가 가능),서비스마다 다른 책임
(느슨한 결합)-공식api를 통해서만 소통,교차로 데이터베이스 접근 금지,자신만의 논리적 스키마를 가짐,spof없음, 일반적인 soa와 다른점,서비스간의 직접 연결 금지
(인터페이스의 유지)-api로 소통하면 내부 구현과 관계없이 일관성 유지,특정 언어로 개발되었다느 가정을 하면 안됨. 재사용성 강화, 각 서비스들간의 계약,버저닝 중요

마이크로서비스의 단위
(엔티티의 액션 단위)
(여러 서비스의 호출 가능)-한 서비스의 api 요청이라고 그 서비스에서만 소화하는 것은 아님, 한 서비스에서 무려 수백개의 서비스가 호출됨
(논리적인 개념, 물리적으로 꼭 나뉠 필요는 없음)

마이크로서비스의 통신-클라이언트와 서비스간의 통신
(http rest 모두 허용, 프로토콜 관계 없음)-public 통신은 http, restful api 쓰는 것 문제 없음, 동기라도 어차피 콜백으로 받음
(직접 통신)-응답을 기다려도 됨
(데이터 쿼리 방식)
 (api 게이트웨이)-병목이 될 수 있음, 자율 원리 위반 가능, 이를 해소하기 위해 여러 api 게이트웨이 확보 가능
 (cqrs)-쓰기와 읽기의 분리,쓰기로 비정규화된 데이터를 준비,읽기를 위한 테이블을 따로 확보, 테이블은 클라이언트 요구 사항에 맞게 설계
 (cold data)-이벤트 통신 혹은 export/import,실시간 데이터가 필요없는 보고서같은 것들에 유용, 실제 업데이트나 트랜잭션 데이터는 마이크로서비스내에 존재.

마이크로서비스의 통신-api 게이트웨이
(역할)-인증,통신보안, 로드 밸런싱, 디스패치(장애 견디기, 서비스 디스커버리 포함), 의존성 해결, 전송 트랜스포메이션
(클라이언트 앱의 요구사항에 맞춰 제작)-backend for frontend
(게이트웨이 나누기)-다른 종류의 클라이언트 앱에 맞춰 분산 필요, 하나로 다하면 또 하나의 monolithic service
(단점)-하나의 spof, 스케일링이 잘 안되면 bottleneck, 응답 시간이 늘어난다(하지만 cli-service간의 빈번한 네트워킹으로 인한 round-trip보다는 낫다), 추가 개발과 유지 보수 필요, endpoint를 항상 제공해주어야 함, 단, api gateway가 보안, 로깅, 버저닝 등에만 관여하고 이것들을 서비스로 위임하면 괜찮음,팀 단위로 나뉘는 것도 좋은 방법


마이크로서비스의 통신-서비스들끼리의 통신
(퍼블릭 콜에 대해 다른 서비스를 부르는 것은 좋지 않다)
(응답을 기다리는 설계는 위험)-call 체인의 위험성, 블럭킹, 성능 저하, 호출수가 크게 증가하면 내부 호출 중 병목 발생, 기하 급수적 로드
(프로토콜)-http, amqp, 바이너리 프로토콜 등
(프로토콜이 무엇이든 응답을 기다리지 않아야 한다)
(다른 서비스 로직을 불러야 한다면 퍼블릭 요청/응답 밖에서 해라)
(장애 복구를 위해 여러번 보낼 필요 있음-수신자는 한번만 처리)
(오케스트레이션)-높은 커플링,점대점연결,서비스가 서비스의 api를 호출,의존성 생김, 서비스의 통합, 변경, 추가가 어려움
(코레오그래피)-낮은 커플링,서비스끼리의 대화 금지,대신 이벤트를 통해 전달,서비스의 변화에 민첩하게 대처,pub/sub,모든 서비스들에 이벤트 던짐(구독한 콘슈머), 이벤트를 받은 서비스들은 각각 필요한 작업을 수행, 각 서비스간의 의존성 없음

데이터의 독립성
(기존 아키텍처는 전체 데이터 중 일부만 사용)
(기존 아키텍처는 acid 트랜잭션, sql query 장점)
(마이크로서비스끼리 같은 데이터를 바라보면 스키마의 수정은 모든 서비스들에 영향을 미침)-독립된 생명 주기를 깨트림, entity간 모델 설계가 달라도 문제 없음. 어느 서비스에서는 유저가 어느 서비스에서는 구매자가 될 수 있음.
(비즈니스 로직이 만들어내는 최종 결과를 관련있는 서비스들이 통지 받아 업데이트)-ddd, 도메인을 잘 기획해야 함
(eventual consistency)

데이터의 일관성 유지
(도메인 설정을 잘 해야 함)
(acid 방식의 사고를 버려야 함)
(어느 정도의 일관성을 포기해야 할 수 있음)
(ui 적으로 해결하는 방법도 해결책)
eventual consistency

장애 처리
(분산 서비스에서 장애가 가장 어려움)
(업그레이드 실패시 자동 롤백)
(자동 재가동까지 고려해야 함, 특히 데이터의 일관성 유지도 매우 중요)
(서비스 장애시 다른 서비스에는 영향을 최소화)
(exponential backoff)
(circuit breaker)

결론
(각 서비스는 단 하나의 문제를 해결한다, 서비스들은 서로를 최대한 몰라야 한다.)-이게 수많은 장점과 어려움들을 만들어냄
(설계가 매우 중요)-spof를 만들지 않고, 서버스의 장애에도 유연하게 대처해야 함, 기존 관념을 버릴 것.
