---
layout: post
title: "[번역] 체크리스트: Node.js 프로덕션 환경을 위한 모범 사례 연구 (2018년 8월)"
date: 2019-03-17 10:58:24
author: Reid
categories:
  - engineering
tags:
  - node.js
  - production
  - best practice
published: false
---

> 원문: [Checklist: Node.JS production best practices (August 2018)](https://goldbergyoni.com/checklist-best-practice-of-node-js-in-production/)

프로덕션 환경에서 Node.js를 실행하는기 위한 저의 종합 팁 모음에 오신 것을 환영합니다. 이 글의 목표는 가장 순위가 높은 블로그 글들로부터 얻은 지식들을 요악하는 것입니다.

**놓치지 마세요**: 각 모범 사례들에는 "GIST Popup" 아이콘이 있습니다. 클릭하면 추가 설명과 인용구, 코드 예제들을 확인 하실 수 있습니다. (역주: 이 번역글에서는 따로 팝업을 띄우지 않고 "GIST" 항목에 내용을 모두 펼쳐서 작성하였습니다)

글 Yoni Goldberg - Node [컨설팅](https://goldbergyoni.com/5-nodejs-services-that-i-offer/)과 [교육](https://courses.goldbergyoni.com/)을 제공하는 독립 Node.JS 컨설턴트. 70개 이상의 모범 사례를 담은 [GitHub](https://github.com/i0natan/nodebestpractices)을 참조하세요.

# 1. 모니터링

**요약**: 모니터링은 고객이 찾아내기 전에 먼저 문제를 찾아내는 게임입니다. 이것은 엄청나게 중요합니다. 요 근래 이 쪽 업계는 많아지는 기능들로 인해 압도되었습니다. 그러므로 반드시 확인해야 하는 기본적인 지표들(안에 제가 추천하는 것들이 있습니다)을 정의하는 것 부터 시작해서 그 후 선호에 따라 추가 기능을 설치하고 목록에서 하나씩 필요한 것들을 만족해나가는 방식으로 접근하세요.

**그렇게 하지 않으면**: 실패 === 실망한 고객들. 간단합니다.

## 한 단락 설명

기본적으로 모니터링은 프로덕션에서 좋지 않은 일이 발생하고 있음을 쉽게 알아차릴 수 있게 해줍니다. 예를 들어, 이메일이나 슬랙 같은 걸로 알림을 받는 것 처럼 말이죠. 문제는 은행 잔고의 압박을 받지 않고, 만족할만한 적당히 도구들을 찾을 수 있느냐는 것입니다. 제안하건데, 이상 없이 잘 돌아가고 있다는 걸 눈으로 확인시켜 줄 수 있는 핵심적인 지표들을 정의하는 것 부터 시작하십시요 - CPU, 서버 RAM, 노드 프로세스 RAM (1.4GB 미만), 마지막 1분 동안의 에러 개수, 프로세스가 재시작한 횟수, 평균 응답 시간 등. 그 후 여러분의 선호에 따라서, 보다 고급 기능들을 살펴보고 위시 리스트에 올려두세요. 고급 모니터링 기능들의 예를 들자면: DB 프로파일링, 교차 서비스 측정 (예: 비즈니스 트랜잭션 측정), 프론트엔드 통합, 커스텀 BI 클라이언트에 raw 데이터 노출, 슬랙 알림 등 여러가지가 있습니다.

고급 기능을 구현하려면 DataDog, newrelic 같은 제품을 돈을 내고 사용해야 합니다. 하지만 안타깝게도, 기본 기능을 구현하는 것 역시 만만치 않습니다. 어떤 지표는 하드웨어만 다루고 어떤 지표는 노드 프로세스만을 다루기 때문에 결국 이처럼 간단한 도구들은 추가적인 설치가 필요합니다. 예를 들어, 클라우드 기반의 모니터링 솔루션(예를 들어, [AWS CloudWatch](https://aws.amazon.com/cloudwatch/), [Google StackDriver](https://cloud.google.com/stackdriver/))은 문제가 생기면 즉시 하드웨어를 측정한 지표들을 제공해주지만, 그 안의 앱이 어떻게 동작하는지는 아무것도 알려주지 않습니다. 반면에, ElasticSearch와 같은 로그 기반의 솔루션들은 대체로 하드웨어 관점에서의 접근이 부족합니다. 해결책은 놓치고 있는 측정 지표들을 기준으로 점차 선택을 넓히는 것입니다. 인기있는 방식을 하나 예로 들어보자면, 애플리케이션 로그들은 Elastic Stack으로 보내고 추가 에이전트(예: Beat)로 하드웨어 관련 정보를 공유하여 전체 그림을 완성시키는 것입니다.

### 모니터링 예제: AWS cloudwatch 기본 대시보드, 인앱 지표는 얻기가 어렵습니다

### 모니터링 예제: StackDriver 기본 대시보드, 인앱 메트릭을 얻기가 어렵습니다

### 모니터링 예제: Grafana를 UI 레이어로 사용하면 raw 데이터를 시각화 해줍니다.

## 다른 블로거의 이야기들

***[blog Rising Stack](http://mubaloo.com/best-practices-deploying-node-js-applications)으로부터***

모든 서비스들에 대해 다음의 지표들을 관찰 하는 것이 좋습니다:<p/>
**에러율**: 에러는 사용자에게 직접 노출되기 때문에, 고객들이 즉시 영향을 받습니다.<br/>
**응답시간**: 늦은 응답시간은 고객과 비즈니스에 직접적인 영향을 줍니다.<br/>
**처리율**: 트래픽은 에러율과 지연시간이 커지는 원인을 파악하는데 도움을 줍니다.<br/>
**포화싱테**: 서비스가 얼마나 "가득"찼는지 알려줍니다. CPU 사용량이 90%인 시스템이 더 많은 트래픽을 처리 할 수 있을까요?

# 2. 스마트 로깅으로 투명성 향상

**요약**: 로그는 디버그 데이터들로 가득찬 의미없는 창고가 될 수도 있고, 앱의 이야기를 전달하는 아름다운 대시보드가 될 수도 있습니다. 첫 날부터 로깅 플랫폼에 대한 계획을 세우십시요. 로그는 어떻게 수집하고 저장하며, 분석 할 것인지 계획을 세워서 원하는 정보(예를 들어, 서비스들과 서버들를 관통하는 전체 트랜잭션 과정의 에러율)를 실제로 얻어낼 수 있도록 합니다.

**그렇게 하지 않으면**: 당신은 원인을 알 수 없는 블랙박스만 남긴채 끝이 나버릴 것이고, 추가 정보들을 입력하기 위해 모든 로그 구문을 다시 작성 할 것입니다.

## 한 단락 설명

어쨌든 로그문을 출력하고 에러와 핵심 지표들을(예: 한 시간 동안 얼마나 많은 에러가 발생했는지, 가장 느린 API 엔드포인트가 무엇인지) 추적 할 수 있는 운영 데이터들을 다룰 인터페이스는 분명히 필요합니다. 요구사항을 모두 만족시키는 강력한 로깅 프레임워크에 적당히 투자해보는건 어떻습니까? 이걸 이루기 위해서는 다음 세 단계의 사려깊은 결단이 필요합니다.

### 1. 스마트 로깅

최소한 [Winston](https://github.com/winstonjs/winston)이나 [Bunyan](https://github.com/trentm/node-bunyan) 같은 명망있는 로깅 라이브러리를 사용해서 각 트랜잭션의 처음과 끝에 의미있는 정보들을 적습니다. 로그는 JSON 형식을 사용하고, 모든 맥락들을 담고 있는 속성들을(예를 들어, 사용자ID, 작업 종류 등) 제공해서 운영팀이 이런 필드들로 액션을 취할 수 있게 하는 것이 좋습니다. 각 로그 라인마다 고유한 트랜잭션 ID를 포함시키는 것도 필요합니다. 자세한 내용은 아래의 'Write transaction-id to log'를 참고하세요. 고려해야 할 마지막 요점은 Elastic Beat와 같은 에이전트를 이용해 메모리나 CPU같은 시스템 자원을 기록하는 것입니다.

### 2. 스마트 수집

서버 파일시스템에서 포괄적인 정보를 얻은 후에는 주기적으로 이 데이터를 집계하고 가공하고 표현하는 시스템에 집어넣어줘야 합니다. 예를 들어, Elastic stack은 데이터를 수집하고 표현하는 모든 컴포넌트을 무료로 선택 할 수 있는 유명한 도구입니다. 많은 유료 제품들이 비슷한 기능을 제공하면서 단지 설치 시간이 크게 줄어들고 호스팅을 할 필요가 없다는 장점만 있습니다.

### 3. 스마트 시각화

수집한 정보로 검색이 가능해지면, 로그 검색이 쉬워졌다는 것 만으로 만족할 수 있겠습니다만 추가로 코딩을 하는 노력을 기울이지 않고도 더 멀리 나아갈 수 있습니다. 이제 우리는 에러율, 일간 CPU 평균 처리량, 지난 한 시간동안 얼마나 많은 신규 사용자들이 유입되었는지 등 앱을 관리하거나 향상시키는데 도움이 되는 중요한 운영 지표들을 확인 할 수 있게 됩니다.

### 시각화 예제: Kibana (Elastic stack의 한 부분)은 로그 내용을 검색하는 고급 기능을 제공합니다.

### 시각화 예제: Kibana (Elastic stack의 한 부분)은 로그 데이터를 기반으로 데이터를 시각화 할 수 있습니다.

### 블로그 인용: 로거 필요 사항

***[Strong Loop 볼르그](https://strongloop.com/strongblog/compare-node-js-logging-winston-bunyan/)로부터***

몇 가지 Logger에 대한 요구 사항을 짚어봅시다.

1. 각 로그 라인에 타임스탬프를 기록해야 합니다. 이 주제는 비교적 자기 설명적입니다. 각각의 로그가 언제 발생했는지 알 수 있어야 합니다.
2. 로깅 포맷은 인간뿐만 아니라 기계에 의해서도 쉽게 처리될 수 있어야 합니다.
3. 여러 대상을 목표로 설정이 가능한 스트림을 사용해야 합니다. 예를 들어, 여러분은 파일에 추적 로그를 기록 할 수 있지만, 에러가 발생하면 그 파일에 기록을 하고나서, 동시에 오류 파일에도 기록을 하고 이메일까지 발송합니다.

# 3. 가능한 모든 것들(예: gzip, SSL)을 reverse proxy에 위임하기

**요약**: Node는 압축, SSL 종료 등 CPU에 민감한 작업을 하기에 몹시 나쁩니다. nginx, HAProxy, Cloud vendor 서비스와 같은 "진짜" 미들웨어 서비스를 사용하세요.

**그렇게 하지 않으면**: 여러분의 불쌍한 싱글 쓰레드는 애플리케이션의 중요한 작업들을 하는 대신 바쁘게 네트워킹 작업들을 계속 하게 되고, 그에 따라 성능은 저하 될 것입니다.

## 한 단락 설명

정적 파일 제공, gzip 인코딩, 요청 쓰로틀링, SSL 종료 등과 같은 네트워크 관련 작업들에 대해 Express의 풍부한 미들웨어를 사용하고 싶은 유혹은 큽니다. 이런 작업들은 CPU를 오랫동안 바쁘게 구동해야 하기 때문에 싱글 쓰레드 모델에서는 성능 저하가 발생합니다. (기억하세요. 노드의 실행 모델은 짧은 작업 또는 비동기 IO 작업에 최적화 되어 있습니다). 더 나은 접근 방식은 네트워킹 작업에 전문화된 도구를 사용하는 것입니다. 가장 널리 사용되는 도구로는 nginx와 HAproxy가 있습니다. 거대한 클라우드 업체들도 node.js 프로세스로 들어오는 부하를 줄이기 위해 이것들을 사용하고 있습니다.

### 코드 예졔: 일반적인 nginx 설정

```nginx
gzip on;

#defining gzip compression
gzip_comp_level 6;
gzip_vary on;upstream myApplication {
  server 127.0.0.1:3000;
  server 127.0.0.1:3001;
  keepalive 64;
}

#defining web server
server {
  listen 80;
  listen 443 ssl;ssl_certificate /some/location/sillyfacesociety.com.bundle.crt;
  error_page 502 /errors/502.html;
  #handling static content
  location ~ ^/(images/|img/|javascript/|js/|css/|stylesheets/|flash/|media/|static/|robots.txt|humans.txt|favicon.ico) {
    root /usr/local/silly_face_society/node/public;
    access_log off;
    expires max;
  }
}
```

## 다른 블로거들의 이야기들

***blog Mubaloo로부터***

...
이 함정에 빠지기는 매우 쉽습니다 -Express 같은 패키지를 보고 생각하죠 "대단해! 이걸로 시작해야겠어!"- 코드를 작성해서 원하는 동작을 하는 애플리케이션을 얻을 수 있습니다. 훌륭합니다. 솔직히, 여러분은 많은 전투에서 승리했다고 생각합니다. 그러나 서버에 앱을 업로드하고 HTTP 포트에서 접속을 기다릴 때, 여러분은 전쟁에서 진 것입니다. 매우 중요한 사실을 잊어버렸기 때문입니다. Node는 웹 서버가 아닙니다. 애플리케이션에 접속이 들어오자마자 문제가 발생하기 시작합니다. 연결이 끊어지거나 asset 제공이 갑자기 멈추고 최악의 경우 서버가 다운됩니다. 여러분이 지금 하고 있는 것은 이미 입증 된 웹 서버들이 정말 잘하는 모든 복잡한 일들을 노드가 처리하도록 하는 것입니다. 왜 바퀴를 다시 발명합니까?

이것은 단지 하나의 이미지에 대한 하나의 요청에 불과합니다. 애플리케이션이 데이터베이스를 읽거나 복잡한 로직을 수행하는 것 같은 중요한 작업을 위해 메모리를 사용해야 한다는 것을 기억해야 합니다. 당신의 편의를 위해 애플리케이션을 절름발이로 만들 셈인가요?
...

***blog Argteam으로부터***

...
Express.js는 미들웨어를 통해 정적 파일들을 처리하는 기능을 내장하고 있지만 결코 사용해서는 안됩니다. Nginx는 정적 파일을 다루는 작업을 훨씬 더 잘 수행 할 수 있으며 비동기 컨텐츠에 대한 요청으로 Node 프로세스가 먹통이 되는 것을 막을 수 있습니다.
...

# 4. dependency 잠그기

**요약**: 모든 환경에서 코드가 동일해야 하지만 놀랍게도 NPM을 사용하면 다양한 환경에서 패키지를 설치할 때 그 최신 패치 버전을 가져 오려고 합니다. NPM의 설정 파일인 `.npmrc`를 사용해서 이 문제를 해결해야 합니다. `.npmrc`는 각 환경에 패키지의 최신 버전이 아닌 일치하는 버전을 저장하게 해줍니다. 또 다른 방법으로, 미세한 제어를 위해 NPM `shrinkwrap`을 사용 할 수 있습니다. **업데이트 : NPM5부터 기본적으로 종속성이 잠깁니다. 새로운 패키지 관리자인 Yarn 역시 기본으로 마찬가지입니다.**

**그렇게 하지 않으면**: QA 담당자가 코드를 철저히 테스트하고도 프로덕션 환경에서 다르게 동작하는 버전을 승인하게 됩니다. 더 문제가 되는 점은 동일한 프로덕션 환경의 클러스터에서 돌아가는 여러 서버가 서로 다른 코드를 실행할 수도 있다는 것 입니다

## 한 단락 설명

여러분의 코드가 여러 외부 패키지에 의존성이 있고, 그 중 `momentjs-2.1.4`를 사용한다고 가정 해 봅시다. 프로덕션 환경에 배포 할 때 NPM이 2.1.5 버전을 가져오는 경우가 발생 할 수도 있습니다. 이는 불행하게도 새로운 버그를 발생시킵니다. NPM 설정 파일을 이용해서 `-save-exact=true`를 설정해두면 NPM이 기존에 설치된 것과 정확하게 일치하는 버전을 참조하도록 지시하고 다음에 "NPM install"(프로덕션 환경이나 Docker 컨테이너 안에서 테스트를 위해 배포될 때)을 실행할 때 같은 종속성을 가진 버전을 내려받게 합니다. 인기 있는 다른 접근 방법으로는 어떤 패키지와 버전이 설치되어야 하는지를 명시하는 `.shrinkwrap` 파일(NPM을 사용해서 쉽게 생성 할 수 있는)을 사용하는 것입니다. 이렇게 해두면 어떤 환경에서도 새 버전을 가져 오지 않게 할 수 있습니다.

**업데이트: NPM5부터는 `.shrinkwrap`을 사용하여 종속성이 자동으로 잠금 시킬 수 있습니다. 떠오르는 패키지 관리자인 Yarn은 기본으로 종속성을 잠급니다**.

### 코드 예제: 정확한 버전을 사용하도록 NPM에 지시하는 .npmrc 파일

```
//save this as .npmrc file on the project directory
save-exact:true
```

### 코드 예제: 정확한 depedency 트리를 추출하는 shirnkwrap.json 파일

```json
{
  "name": "A",
  "dependencies": {
    "B": {
      "version": "0.0.1",
      "dependencies": {
        "C": {
          "version": "0.1.0"
        }
      }
    }
  }
}
```

### 코드 예제: NPM 5 종속성 잠금 파일 - package.json

```json
{
  "name": "package-name",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "dependencies": {
    "cacache": {
      "version": "9.2.6",
      "resolved": "https://registry.npmjs.org/cacache/-/cacache-9.2.6.tgz",
      "integrity": "sha512-YK0Z5Np5t755edPL6gfdCeGxtU0rcW/DBhYhYVDckT+7AFkCCtedf2zru5NRbBLFk6e7Agi/RaqTOAfiaipUfg=="
    },
    "duplexify": {
      "version": "3.5.0",
      "resolved": "https://registry.npmjs.org/duplexify/-/duplexify-3.5.0.tgz",
      "integrity": "sha1-GqdzAC4VeEV+nZ1KULDMquvL1gQ=",
      "dependencies": {
        "end-of-stream": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.0.0.tgz",
          "integrity": "sha1-1FlucCc0qT5A6a+GQxnqvZn/Lw4="
        },
```

# 5. 올바른 도구로 프로세스의 실행 유지하기

**요약**: 프로세스는 계속 실행 상태여야 하고, 오류가 발생해서 꺼지더라도 재시작 되어야 합니다. 간단한 상황에서는 PM2와 같은 재시작 도구로 충분하지만, 요즘은 'dockerized' 세상입니다 - 클러스터 관리 도구 역시 고려되어야 합니다.

**그렇게 하지 않으면**: 명확한 전략 없이 수십개의 인스턴스를 실행하거나, 너무 많은 도구(클러스터 관리, Docker, PM2)들을 사용하면 devops는 혼돈의 카오스가 될 것 입니다.

## 한 단락 설명

노드 프로세스는 장애가 발생하면 기본적인 수준에서는 보호받고 재시작이 가능해야합니다. 컨테이너를 사용하지 않고 조그만 애플리케이션을 만드는 개발자에게 [PM2](https://www.npmjs.com/package/pm2-docker)와 같은 도구는 복잡하지 않으면서도 재시작 기능 등 노드와의 풍부한 통합을 제공하기 때문에 안성맞춤입니다. 뛰어난 Linux 기술을 가진 사람들은 systemd를 사용해서 노드를 서비스로 실행할 수 있습니다. Docker 등의 컨테이너 기술을 사용하는 앱의 경우 일반적으로 함께 제공되는 클러스터 관리 도구(예: [AWS ECS](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html), [Kubernetes](https://kubernetes.io/) 등)로 모니터링 기능이나 스스로 회복되는 컨테이너 기능을 사용 할 수 있습니다. 풍부한 클러스터 관리 기능에다가 컨테이너의 재시작 기능까지 있는데, PM2와 같은 다른 도구들을 굳이 사용해서 엉망을 만들 필요가 있습니까? 그에 대해 확답을 내리기는 힘듭니다. 프로세스를 가장 앞에서 보호해 줄 녀석으로 PM2를(컨테이너 전용 버전으로 [pm2-docker](https://www.npmjs.com/package/pm2-docker)가 대부분 사용됨) 사용해야 하는 좋은 이유가 있습니다. 프로세스의 재시작은 훨씬 빠르고, 호스팅 컨테이너가 우아한 재시작을 요청 할 때, 코드에 플래그를 지정하는 것과 같은 노드에 특화된 기능들을 제공하기 때문입니다. 어떤 이들은 불필요한 레이어를 만드는 것을 원하지 않을 수도 있습니다. 정리하며 마무리를 해야겠습니다. 모두에게 딱 맞는 해결책은 없습니다. 다만 어떤 옵션이 있는지는 알고 있어야 합니다.

## 다른 블로거의 이야기들

*[Express Production Best Practices](https://expressjs.com/en/advanced/best-practice-performance.html) 로부터*

...
개발 과정에서 여러분은 간단히 `node server.js`를 입력하거나 또는 비슷한 방식을 이용해서 앱을 실행시켰습니다. 그러나 프로덕션 환경에서 이처럼 프로세스를 시작하는 것은 재앙을 불러일으키는 것입니다. 만약 앱이 크래시가 난다면 다시 시작시킬 때까지 앱은 오프라인 상태가 됩니다. 애플리케이션을 자동으로 재시작 시키기 위해 프로세스 관리자를 사용하십시오. 프로세스 관리자는 배포를 용이하게 하고 가용성을 높이며 실행 시 애플리케이션을 관리 하도록 해주는 애플리케이션을 위한 "컨테이너"입니다. 
...

*[블로그 Medium: 노드 클러스터링 이해가기](https://medium.com/@CodeAndBiscuits/understanding-nodejs-clustering-in-docker-land-64ce2306afef#.cssigr5z3)로부터*

Docker-Land에서 NodeJS 클러스터링 이해하기

"Docker 컨테이너는 프로세스를 최소화시키기 위해 설계된 간소화되고 가벼운 가상 환경입니다. 자신의 리소스를 관리하고 조정해야하는 프로세스는 더 이상 가치가 없습니다. Kubernetes, Mesos, Cattle과 같은 관리 스택은 이러한 리소스를 인프라 차원에서 관리해야한다는 개념을 대중화시켰습니다. CPU와 메모리 리소스는 "스케줄러"에 의해 할당되고 네트워크 리소스는 스택이 제공하는 로드 밸런서에 의해 관리됩니다.

# 6. 오류 관리 모범 사례를 충족시킵시다
**요약**:  Node.JS 환경을 안정적으로 유지시키기 위한 작업 중 오류에 대한 처리가 가장 오래 걸리고 가장 고통스럽니다. 이것은 주로 '단일 스레드' 모델과 비동기 흐름에서 오류 경로에 대해 적절히 처리 할 전략이 없기 때문에 발생합니다. 여기에는 간단한 방법이란 없습니다. 오류 라는 짐승을 잡기 위해서는 그것을 이해하고 길들이는데 공을 들여야 합니다. 제 오류 처리 모범 사례 목록은 이를 좀 더 빠르게 해드릴 수 있습니다.

**그렇게 하지 않으면**: 사용자가 잘못된 JSON을 전달했다는 이유로 프로세스에 문제가 발생하고 추적 오류는 사라지며 사용자에게 에러 스택 정보가 공개되는 등 미친일들이 계속됩니다.

# 7. 모든 CPU 코어를 활용하세요

**요약**: Node는 기본적으로 단일 CPU 코어에서 실행되고 다른 모든 프로그램은 유휴 상태가 됩니다. 여러 노드 프로세스를 띄워서 모든 CPU를 활용하는 것은 선택이 아니라 의무입니다. 중형 애플리케이션의 경우 노드 클러스터 또는 PM2를 사용할 수도 있습니다. 보다 큰 애플레키에션에서는 Docker 클러스터(예: K8S, ECS) 또는 Linux init 시스템(예: systemd)을 기반으로 하는 배포 스크립트를 사용해서 프로세스를 복제하는 것이 좋습니다.

**그렇게 하지 않으면:** 앱이 리소스(!) 중 25%만 활용 할 가능성이 있습니다. 보통의 서버는 CPU 코어가 4개 이상인 점에 유의하세요. 나이브하게 배포하는 경우 코어를 단 1개만 사용하게 됩니다 (AWS Beanstalk와 같은 PaaS 서비스를 사용하더라도!).

## 한 단락 설명

Node가 단일 스레드=단일 프로세스=단일 CPU로 실행된다는 것은 놀랄 일도 아닙니다. 4개 또는 8개의 CPU가 있는 비싼 하드웨어를 사서 단 한 개만 사용한다는 건 그냥 미친거 아닙니까? 중간 규모의 애플리케이션에게 가장 적당하고 빠르게 적용 할 수 있는 해결책은 노드의 클러스터 모듈을 사용하는 것입니다. 이 모듈은 10줄의 코드만으로 각각의 코어에 프로세스를 생성하고 라운드 로빈 방식으로 프로세스간 요청을 라우팅합니다. 더 좋은 방법은 간단한 인터페이스와 멋진 모니터링 UI로 클러스터링 모듈을 사용 가능한 PM2를 사용하는 것입니다. 일반적인 애플리케이션에서는 이 방법이 잘 작동하지만, 최고 수준의 성능과 강력한 devops 플로우가 필요한 애플리케이션에게는 적합하지 않습니다. 고급 사용 사례의 경우, nginx 같은 특별한 도구를 사용해서 커스텀 배포 스크립트를 작성하고 로드 밸런싱을 해주거나 AWS ECS나 Kubernetees 같은 컨테이너 엔진을 이용해야 합니다. 이것들은 프로세스를 배치시키고 복제하는 고급 기능들을 가지고 있습니다.

## 밸런싱 비교: 노드 클러스터 vs nginx

## 다른 블로거의 이야기들

*[Node.JS 문서](https://nodejs.org/api/cluster.html#cluster_how_it_works)*에서

...두 번째 접근 방법인 노드 클러스터는 이론상 최고의 성능을 제공해야 합니다. 그러나 실제로는 운영 체제의 스케줄러 변경으로 인해 배포가 매우 불균형해지는 경향이 있습니다. 모든 접속의 70% 이상이 총 8 개의 프로세스 중 단지 두개의 프로세스에서만 종료되는 부하가 관찰되었습니다...

*[StrongLoop 블로그](https://strongloop.com/strongblog/best-practices-for-express-in-production-part-two-performance-and-reliability/)에서*

...노드의 클러스터 모듈을 사용하여 클러스터링이 가능합니다. 이렇게 하면 마스터 프로세스가 작업 프로세스를 생성하고 들어오는 연결을 작업자에게 배분 할 수 있습니다. 그러나 이 모듈을 직접 사용하지 말고 자동으로 처리해주는 도구들 중 하나를 사용하는 것이 훨씬 낫습니다. 예를 들어 node-pm 또는 cluster-service...

*[클러스터 모듈, iptables 및 Nginx를 비교](https://medium.com/@fermads/node-js-process-load-balancing-comparing-cluster-iptables-and-nginx-6746aaf38272)하는 블로그에서*
...노드 클러스터는 설정과 구현이 간단하고, 다른 소프트웨어에 의존성 없이 Node 단계에서 사용 할 수 있습니다. 마스터 프로세스는 작업자 프로세스와 거의 비슷하게 작동하지만 다른 솔루션들에 비해 요청률은 조금 떨어진다는 점만 기억하세요.

# 8. 유지 보수를 위한 엔드포인트를 만듭니다.

**요약**: 보안이 된 API를 통해 메모리의 사용이나 REPL등과 같은 시스템 관련 정보를 제공합니다. 표준적인 혹은 전투적인 테스트 도구를 사용하는 것은 매우 추천 할 만 하지만 코드를 사용해서 유용한 정보나 작업을 쉽게 수행 할 수 있습니다.

**그렇게 하지 않으면**: 단지 진단을 목적으로 시스템 정보를 얻어내기 위해 프로덕션으로 코드를 전송하는 "진단 배포"를 자주 수행하게 됩니다.

## 한 단락 설명
유지 보수를 위한 엔드포인트는 앱 코드로 제작하는 일반 보안 HTTP API입니다. 이 엔드포인트는 운영팀이 여러 유용한 기능을 호출하거나 정보를 확인 하는 용도로 사용됩니다. 예를 들어 프로세스의 헤드 덤프 (메모리 스냅샷)를 넘겨주거나 메모리 누수가 있는지 보고하고 REPL 명령을 직접 실행할 수도 있습니다. 이 엔드포인트는 기존의 devop 도구(모니터링 제품, 로그 등)가 특정 유형의 정보를 수집하지 못한다거나 이러한 도구를 구매, 설치하지 않기로 한 경우에 필요합니다. 가장 좋은 방법은 프로덕션을 모니터링하고 유지 관리하는데 필요한 전문적인 외부 도구를 사용하는 것이며 이것이 일반적으로 보다 강력하고 정확합니다. 즉, 일반 도구는 Node 또는 여러분의 앱이 얻고자 하는 정보를 제공하지 못 할 수 있습니다. 예를 들어, GC가 컴파일 싸이클을 완료 한 순간의 메모리 스냅샷이 필요한 경우가 있을 수 있습니다. 몇몇 NPM 라이브러리들은 이런 요구를 아주 잘 수행하지만, 일반적인 모니터링 도구들은 이런 기능이 없을 가능성이 큽니다.

### 코드 예제: 코드를 통해 헤드 덤프 생성

```javascript
var heapdump = require('heapdump');
 
router.get('/ops/headump', (req, res, next) => {
  logger.info(`About to generate headump`);
  heapdump.writeSnapshot(function (err, filename) {
    console.log('headump file is ready to be sent to the caller', filename);
    fs.readFile(filename, "utf-8", function (err, data) {
      res.end(data);
    });
  });
});
```

### 볼거리 추천

*[Node.js 앱 프로덕션 준비하기](Getting your Node.js app production ready)*

# 9. APM 제품을 사용하여 오류 및 다운타임 발견
**요약**: 제품의 성능을 모니터링하는 제품(APM이라고도 함)은 제품의 코드나 API를 사전에 측정하여 자동으로 기존 모니터링의 한계를 뛰어 넘어 서비스 전반에서 사용자의 경험을 측정합니다. 예를 들어 일부 APM 제품은 최종 사용자 측면에서 너무 느리게 로드되는 트랜잭션을 짚어주며 근본적인 원인을 제안 할 수 있습니다.

**그렇게 하지 않으면**: API 성능, 가동 중지 시간을 측정하는 데 많은 노력을 기울여야 합니다. 실제 시나리오에서 가장 느린 코드가 어디있는지 찾을 수 없고, 이것이 UX에 미치는 영향 또한 알지 못할 것입니다

## 한 단락 설명

APM, 애플리케이션 프로그램 성능 모니터링은 애플리케이션의 성능을 고객의 관점에서, end to end 모니터링하는 것을 목표로 하는 제품군을 말합니다. 전통적인 모니터링 솔루션은 예외나 stand-alone의 기술적 지표(예: 오류 추적, 서버 엔드 포인트 속도 저하 등)에 중점을 두고 있지만 실제로는 일부 미들웨어 서비스가 느린 경우가 발생하면 코드의 예외 없이도 얼마든지 사용자를 실망시킬 수 있습니다. APM 제품은 말단에서 말단까지(end to end) 유저 경험을 측정합니다. 예를 들자면, 프론트 엔드 UI에서부터 다중 분산 서비스를 포함하는 시스템까지를 측정 할 수 있습니다. 일부 APM 제품은 여러 계층에 걸쳐진 트랜잭션이 얼마나 빠른지 파악 할 수 있습니다. 이로써 사용자 경험에 문제가 없는지 지적 할 수 있습니다. 이처럼 제품은 매력적이지만 상대적으로 높은 가격을 가지고 있기 때문에, 선형적인 모니터링을 넘어서야 하는 대규모의 복잡한 제품에 권장됩니다.

### APM 예제 - 교차 서비스 앱 성능을 시각화 한 상용 제품

### APM 예제 - 사용자 경험 점수를 강조하는 상용 제품

### APM 예제 - 느린 코드 경로를 강조하는 상용 제품

10. 코드 제작 준비 완료
TL : DR 을 염두에두고 최종적으로 코드를 작성하여 1 일째부터 생산 계획을 세웁니다. 약간 흐릿 해져서 제작 유지 보수와 밀접하게 관련된 몇 가지 개발 팁을 내부에서 컴파일했습니다 (아래의 요지를 클릭하십시오).

그렇지 않으면 : 세계 챔피언 IT / devops 남자가 잘못 작성된 시스템을 저장하지 않습니다

코드 제작 준비 완료
한 단락 설명자
다음은 생산 유지 보수 및 안정성에 크게 영향을주는 개발 팁 목록입니다.

12 요소 가이드 - 12 요소 안내서를 숙지하십시오.
무 상태 유지 - 특정 웹 서버에 로컬로 데이터 저장 안 함 ( 별표 - '상태 비 저장'참조)
캐시 - 캐시를 많이 활용하지만 캐시 불일치로 인해 결코 실패하지 마십시오.
테스트 메모리 - 게이지 메모리 사용 및 누출을 개발 흐름의 일부로 'memwatch'와 같은 도구로이 작업을 크게 촉진 할 수 있습니다.
이름 함수 - 일반적인 메모리 프로파일 러가 
메소드 이름 당 메모리 사용을 제공하므로 익명 함수 (즉, 인라인 콜백)의 사용을 최소화하십시오.
CI 도구 사용 - CI 도구를 사용하여 생산에 보내기 전에 오류를 감지합니다. 예를 들어, 참조 오류 및 정의되지 않은 변수를 탐지하려면 ESLint를 사용하십시오. 동기식 API (비동기 버전 대신)를 사용하는 코드를 식별 하려면 -trace-sync-io 를 사용하십시오.
로그를 현명하게 - 각 로그 문맥 정보를 JSON 형식으로 포함시켜 Elastic과 같은 로그 애그리 게이터 도구가 해당 속성을 검색 할 수 있도록하십시오 (별도의 글 머리 기호 - '스마트 로그를 사용하여 가시성 높이기'참조). 또한 각 요청을 식별하고 동일한 트랜잭션을 설명하는 행을 상호 연관시킬 수있는 transaction-id를 포함하십시오 (별도의 글 머리 기호 'Include Transaction-ID'참조).
오류 관리 - 오류 처리는 Achilles의 Node.JS 생산 사이트의 발단입니다. 많은 노드 프로세스가 사소한 오류로 인해 충돌하는 반면, 다른 노드 프로세스는 오류가 발생하지 않고 오류 상태로 정지합니다. 오류 처리 전략을 설정하는 것이 절대적으로 중요합니다. 여기서 오류 처리 모범 사례를 읽으십시오. 

11. 명백한 보안 상자에 눈금을 표하십시오.
TL : DR : 노드는 몇 가지 고유 한 보안 문제를 구현합니다.이 글에서 간단한 보안 조치를 그룹화했습니다. "보안"시스템이 훨씬 더 광범위한 보안 분석을 필요로한다는 말을하지 않고 이동합니다.

그렇지 않은 경우 :  언론에 보도 된 보안 누출보다 더 가치가있는 것은 무엇입니까? 방금 잊어 버렸던 간단하지 않은 보안 문제

한 단락 설명자
보안은 전문 트레이너가 길들여야하는 커다란 코끼리입니다. 다음은 거의 모든 앱에서 실시간으로 적용해야하는 일반적인 보안 관련 목록입니다. 분명히 그것은 단지 보안 빙산의 일각을 다루고 있습니다.

(1) VPN - 당신의 컴퓨터에 SSH에 개인 네트워크 (VPC, VPN)을 생성 
(2) TLS - SSL / TLS 어떤 비즈니스 트랜잭션을 보호 
(3) Paramterized SQL - 저장 프로 시저 또는 매개 변수화 된 쿼리를 사용하여 SQL 주입 공격을 피하기 
( 4) 신중한 HTTP 헤더 - Express를 사용할 때 기본적으로 전송되는 HTTP 헤더 (예 : X-XSS- 보호 헤더)를 보냅니다. 이것은 자신을 코딩하기 쉽지만 실제로 다른 브라우저는 큰 차이를 가진 특정 헤더를 처리하고 헤더 값은 현재 사용자 에이전트와 일치해야합니다. 패키지 "npm Helmet"이 지루한 작업을 수행 할 수 있습니다. 
(5) 쿠키를 안전하게 사용하십시오. httpOnly, path, domain과 같은 쿠키 속성을 설정하여 쿠키 사용을 제한하고 일반적인 공격을 예방하십시오. 아래 코드 예제를 참조하십시오.

다른 블로거가 말하는 것

블로그에서 익스프레스 보안 베스트 프랙티스
... 헬멧을 사용하고 싶지 않다면 적어도 X-Powered-By 헤더를 비활성화하십시오. 공격자는이 헤더 (기본적으로 활성화되어 있음)를 사용하여 Express를 실행하는 응용 프로그램을 감지 한 다음 특정 대상 공격을 시작할 수 있습니다. 따라서 app.disable () 메소드로 헤더를 해제하는 것이 가장 좋습니다. app.disable ( 'x-powered-by')

코드 예 : 'Helmet'- 몇 줄의 코드로 많은 유형의 공격을 차단하는 NPM 패키지

코드 예제 : 쿠키를 안전하게 설정

12. 메모리 사용을 측정하고 보호하십시오.
TL :  Node.js는 메모리와 논란의 여지가 있습니다. v8 엔진은 메모리 사용량 (1.4GB)에 대한 제한이 있으며 노드의 코드에서 메모리를 누설하는 경로가 알려져 있습니다. 따라서 노드의 프로세스 메모리를 관찰하는 것이 필수적입니다. 작은 응용 프로그램에서는 셸 명령을 사용하여 주기적으로 메모리를 측정 할 수 있지만 중간 규모의 대형 응용 프로그램에서는 메모리 감시 장치를 견고한 모니터링 시스템으로 굽는 것이 좋습니다

그렇지 않은 경우 :  월마트 에서 발생한 것처럼 하루에도 수백 메가 바이트의 프로세스 메모리가 누출 될 수 있습니다.

메모리 사용량 측정 및 보호
한 단락 설명자
완벽한 세계에서 웹 개발자는 메모리 누수를 처리해서는 안됩니다. 실제로, 메모리 문제는 노드가 알고 있어야하는 알려진 노드입니다. 무엇보다도 메모리 사용을 지속적으로 모니터링해야합니다. 개발 및 소규모 생산 사이트에서는 Linux 명령이나 NPM 도구와 node-inspector 및 memwatch와 같은 라이브러리를 사용하여 수동으로 측정 할 수 있습니다. 이 수동 작업의 주된 단점은 사람이 적극적으로 모니터링해야한다는 것입니다. 심각한 생산 현장의 경우 누출 발생시 경고하는 강력한 모니터링 도구 (예 : AWS CloudWatch, DataDog 또는 유사한 사전 예방 적 시스템)를 사용하는 것이 절대적으로 중요합니다. 또한 누출을 방지하기위한 개발 가이드 라인이 거의 없습니다. 글로벌 레벨에 데이터를 저장하지 말고 동적 크기의 데이터에 스트림을 사용하고 let 및 const를 사용하여 변수 범위를 제한하십시오.

다른 블로거가 말하는 것
블로그에서 Dyntrace
... "이미 배웠 듯이 Node.js에서 JavaScript는 V8에 의해 네이티브 코드로 컴파일됩니다. 최종 네이티브 데이터 구조는 원래 표현과 관련이 없으며 V8에서 단독으로 관리합니다. 즉, JavaScript에서 메모리를 능동적으로 할당하거나 할당을 해제 할 수 없습니다. V8은 가비지 콜렉션이라는 잘 알려진 메커니즘을 사용하여이 문제를 해결합니다. "  
블로그에서 Dyntrace
"이 예는 명백한 결과를 초래 있지만 과정은 항상 동일합니다 : 
약간의 시간 사이에서 메모리 할당의 공정한 양 힙 덤프를 작성 
성장하고 있는지 확인하려면 몇 덤프를 비교" 
...
블로그에서 Dyntrace
"오류가 발생하면 Node.js는 약 1.5GB의 메모리를 사용하려고합니다.이 메모리는 메모리가 적은 시스템에서 실행할 때 제한이 있습니다. 이것은 가비지 수집이 매우 비용이 많이 드는 작업이므로 예상되는 동작입니다. 
그 해결책은 Node.js 프로세스에 추가 매개 변수를 추가하는 것입니다. 

13. 노드에서 프론트 엔드 자산 가져 오기
TL : 단일 스레드 모델로 인해 많은 정적 파일을 처리 할 때 노드 성능이 실제로 손상되기 때문에 전용 미들웨어 (nginx, S3, CDN)를 사용하여 프론트 엔드 컨텐츠를 제공합니다.

그렇지 않으면 : 하나의 노드 스레드가 태어난 작업에 대한 모든 리소스를 할당하는 대신 수백 개의 html / images / angular / react 파일을 스트리밍하면서 바쁘게 유지합니다.

한 단락 설명자
고전적인 웹 응용 프로그램에서 백엔드는 브라우저에 프론트 엔드 / 그래픽을 제공하므로 노드의 세계에서 매우 일반적인 접근 방식은 클라이언트에 staitc 파일을 합리화하기 위해 Express 정적 미들웨어를 사용하는 것입니다. 하지만 한 번에 많은 파일을 제공하도록 최적화되지 않은 단일 스레드를 사용하기 때문에 노드는 일반적인 웹 응용 프로그램이 아닙니다. 대신,이 작업에 대한 많은 최적화를 활용하고 훨씬 더 높은 처리량을 얻는 역방향 프록시, 클라우드 저장소 또는 CDN (예 : Nginx, AWS S3, Azure Blob 저장소 등)을 사용하는 것을 고려하십시오. 예를 들어, nginx와 같은 미들웨어는 파일 시스템과 네트워크 카드 간의 직접 연결과 다중 스레드 접근 방식을 구현하여 다중 요청 간의 간섭을 최소화합니다.

최적의 솔루션은 다음 양식 중 하나를 사용할 수 있습니다. (1) 역방향 프록시 - 정적 파일은 노드 응용 프로그램 바로 옆에 위치하며 정적 파일 폴더에 대한 요청은 사용자의 앞에있는 프록시에 의해 제공됩니다 nginx와 같은 노드 응용 프로그램. 이 접근 방식을 사용하면 노드 응용 프로그램이 정적 파일을 배포하지만 서비스를 제공하지 않아야합니다. 프론트 엔드의 동료는 프론트 엔드 (2) 로부터의 크로스 - 오리진 요청을 방지하므로이 접근법을 좋아할 것입니다.클라우드 스토리지 - 정적 파일은 노드 앱 콘텐츠의 일부가 아니며 AWS S3, Azure BlobStorage 또는이 미션을 위해 탄생 한 기타 유사한 서비스에 업로드됩니다. 이 접근 방식을 사용하면 노드 앱이 정적 파일 배포를 책임지지 않으므로 다른 팀에서 처리하는 노드와 프런트 엔드간에 완벽한 디커플링이 발생합니다

코드 예제 : 정적 파일을 제공하기위한 일반적인 nginx 구성

다른 블로거가 말하는 것
 
StrongLoop 블로그  에서
... 개발 중에는 [res.sendFile ()] ( http : // expressjs . com / 4x / api . html # res . sendFile )을 사용하여 정적 파일을 제공 할 수 있습니다. 하지만이 기능은 프로덕션 환경에서 수행하지 마십시오.이 기능은 모든 파일 요청에 대해 파일 시스템에서 읽어야하므로 상당한 지연이 발생하고 앱의 전반적인 성능에 영향을 미칩니다. res.sendFile ()은 sendfile 시스템 호출로 구현되지 않았으므로 훨씬 더 효율적입니다. 대신 Express 애플리케이션 용 파일 제공에 최적화 된 서브 - 정적 미들웨어 (또는 이와 동등한 것)를 사용하십시오. 보다 나은 옵션은 정적 파일을 제공하기 위해 역방향 프록시를 사용하는 것입니다. 자세한 내용은 역방향 프록시 사용을 참조하십시오.  

14. 무국적으로 거의 매일 서버를 제거하십시오.
TL; DR : 외부 데이터 저장소에 모든 유형의 데이터 (예 : 사용자 세션, 캐시, 업로드 된 파일)를 저장합니다. 서버를 주기적으로 '죽이는'것을 고려하거나 명시 적으로 무국적 행동을 시행하는 'serverless'플랫폼 (예 : AWS Lambda)을 사용하십시오

그렇지 않은 경우 : 특정 서버에서 오류가 발생하면 오류가 발생한 시스템을 종료하는 대신 응용 프로그램이 중단됩니다. 게다가 특정 서버에 의존하기 때문에 수평 확장 성이 더욱 어려워 질 것입니다

한 단락 설명자
한 서버에서 일부 구성 또는 데이터가 누락 된 심각한 생산 문제가 발생 했습니까? 이는 배포에 포함되지 않은 일부 로컬 자산에 대한 불필요한 종속성 때문일 수 있습니다. 많은 성공한 제품은 피닉스 새와 같은 서버를 처리합니다. 이는 손상없이 주기적으로 사망하고 중생합니다. 즉, 서버는 잠시 동안 코드를 실행 한 다음 교체되는 하드웨어 조각 일뿐입니다. 이 접근 방법 (a)은 부작용없이 서버를 동적으로 추가 및 제거하여 확장 할 수 있으므로 (b) 유지 관리가 간단 해져 각 서버 상태를 평가할 필요가 없습니다 
.

코드 예제 : 안티 패턴

다른 블로거가 말하는 것
블로그에서 M artin Fowler
... 어느 날 나는 운영을위한 인증 서비스를 시작한다는 환상을 보았습니다. 인증 평가는 동료로 구성되며 회사 데이터 센터에서 야구 방망이, 전기 톱 및 물총으로 중요한 프로덕션 서버를 설정합니다. 평가는 운영 팀이 모든 응용 프로그램을 다시 실행하는 데 걸리는 시간을 기준으로합니다. 위선적 인 판타지 일 수도 있지만 여기에 지혜가 있습니다. 야구 방망이를 피하는 동안 정기적으로 서버를 거의 태우는 것이 좋습니다. 서버는 피닉스와 같아야하며 정기적으로 재에서 상승해야합니다. ... 

15. 자동으로 취약점을 탐지하는 도구 사용
TL : DR : Express와 같은 가장 신뢰할만한 종속성조차도 시스템을 위험에 빠뜨리는 취약성을 수시로 알고 있습니다. 이는 취약성을 지속적으로 확인하고 (로컬 또는 GitHub에서) 경고하는 커뮤니티 및 상용 도구를 사용하여 쉽게 길들이기가 가능하며 일부는 즉시 패치 할 수도 있습니다

그렇지 않으면 : 헌신적 인 도구없이 취약점으로부터 코드를 깨끗하게 유지하려면 새로운 위협에 대한 온라인 간행물을 지속적으로 따라야합니다. 아주 지루한

한 단락 설명자
StrongLoop의 블로그에서 다음과 같은 단어를 정말 좋아합니다. "앱 보안은 의존성이 가장 약한 링크만큼 강력합니다." 코드 의존성은 실제로 가장 유명하고 전투 테스트를 거친 패키지조차도 종종 취약점을 갖는 경향이 있습니다. 예를 들어, 이전 버전의 Express에서 교차 사이트 스크립팅 공격에 사용자를 노출시킬 수있는 위협 요소가 감지되었습니다. 다행스럽게도 nsp 및 snyk과 같은 커뮤니티 및 상업 도구 (모든 공용 계획은 최소한 공용 저장소가 있음)는 이러한 위협에 대해 자동으로주의를 기울여 팀에 경고하고 나중에 이러한 취약점을 자동으로 패치 할 수 있습니다

다른 블로거가 말하는 것
프로덕션 환경에서의 우수 사례
... 응용 프로그램의 종속성을 관리하는 것은 강력하고 편리합니다. 그러나 사용하는 패키지에는 응용 프로그램에 영향을 줄 수있는 심각한 보안 취약점이있을 수 있습니다. 앱 보안은 의존성의 "약한 링크"만큼 강력합니다. 다행히도 사용하는 타사 패키지를 확인하는 데 사용할 수있는 유용한 도구가 두 가지 있습니다. requireSafe. 이 두 가지 도구는 대체로 똑같은 기능을 수행하므로 과도한 사용은 가능할 수 있지만 "미안한 것보다 안전합니다"는 보안과 관련된 단어입니다 ...  
코드 예제 : 전형적인 nginx 설정

16. 각 트랜잭션 문에 'TransactionId'를 지정하십시오.
TL : DR : 단일 요청 내의 각 로그 항목에 동일한 식별자 인 transaction-id : {some value}를 할당합니다. 그런 다음 로그의 오류를 검사 할 때 이전과 이후의 상황을 쉽게 결론 지을 수 있습니다. 불행히도, 비동기 성 때문에 Node에서 달성하기가 쉽지 않습니다. 내부의 코드 예제를보세요.

그렇지 않은 경우 : 컨텍스트없이 프로덕션 오류 로그를보고 (이전에는 어떤 일이 있었는지) 문제를 훨씬 더 어렵게하고 느리게 만듭니다.

한 단락 설명자
일반적인 로그는 모든 구성 요소 및 요청 항목의웨어 하우스입니다. 의심스러운 라인이나 오류가 감지되면 동일한 특정 흐름 (예 : 사용자 "John"이 무언가를 사려고하는 등)에 속하는 다른 라인과 일치하도록 털이됩니다. 요청 / 트랜잭션이 여러 컴퓨터에 걸쳐있을 때 마이크로 서비스 환경에서는 이것이 더욱 중요 해지고 도전적입니다. 같은 요청에서 모든 항목에 고유 한 트랜잭션 ID 값을 할당하여이 문제를 해결하십시오. 따라서 한 행을 검색 할 때 id를 복사하고 유사한 트랜잭션 ID를 가진 모든 행을 검색 할 수 있습니다. 그러나 요청 레벨에서 데이터를 그룹화 할 수있는 라이브러리를 사용하여 모든 요청을 처리하는 데 단일 스레드가 사용되므로이 노드를 달성하는 것은 쉽지 않습니다. 다음 슬라이드의 코드 예제를 참조하십시오. 다른 마이크로 서비스를 호출 할 때,
.

코드 예제 : 전형적인 nginx 설정

블로그에서 Argteam
Express.js는 일부 미들웨어를 통해 정적 파일 처리 기능을 내장하고 있지만 결코 사용해서는 안됩니다. Nginx는 정적 파일을 다루는 작업을 훨씬 더 잘 수행 할 수 있으며 비 동적 컨텐츠에 대한 요청이 노드 프로세스를 막히게 할 수 있습니다 ...  

17. NODE_ENV = 생산을 설정하십시오.
TL : 환경 변수 NODE_ENV를 'production'또는 'development'로 설정하여 생산 최적화가 활성화되어야하는지 여부를 표시 - 현재 환경을 결정하고 생산을 위해 코드를 최적화하는 많은 NPM 패키지

그렇지 않으면 : 이 간단한 속성을 생략하면 성능이 크게 저하 될 수 있습니다. 예를 들어 서버 쪽 렌더링에 Express를 사용하면 NODE_ENV를 생략하면 느려집니다.

한 단락 설명자
프로세스 환경 변수는 일반적으로 구성 목적을 위해 실행중인 프로그램에서 사용할 수있는 키 - 값 쌍의 집합입니다. 모든 변수를 사용할 수 있지만, Node는 NODE_ENV라는 변수를 사용하여 우리가 지금 생산 중인지 여부를 표시하도록 권장합니다. 이 결정은 구성 요소가 캐싱을 사용 불가능하게하거나 자세한 로그 문을 표시하는 등 개발 중에 더 나은 진단을 제공 할 수 있도록합니다. 현대 배포 도구 인 Chef, Puppet, CloudFormation 등은 배포 중에 환경 변수 설정을 지원합니다 
.

코드 예 : NODE_ENV 환경 변수 설정 및 읽기

다른 블로거가 말하는 것
블로그에서 ynatrace : 실적 정보
...... Node.js에는 NODE_ENV라는 변수를 사용하여 현재 모드를 설정하는 규칙이 있습니다. 우리는 실제로 NODE_ENV를 읽고 이것이 설정되어 있지 않으면 'development'로 기본 설정되어 있음을 봅니다. NODE_ENV를 프로덕션 환경으로 설정하면 Node.js가 CPU 사용량이 약간 떨어지는 동안 약 2/3만큼 점프를 처리 할 수 ​​있습니다. 이것을 강조하겠습니다. NODE_ENV를 프로덕션 환경으로 설정하면 응용 프로그램이 3 배 빨라집니다! ...

18. 자동, 원자력 및 제로 다운 타임 배치 설계
TL : 많은 연구를 수행하는 팀이 심각한 생산 문제의 가능성을 낮추는 연구. 위험한 수작업 단계 및 서비스 중단 시간이 필요하지 않은 신속하고 자동화 된 배포로 배포 프로세스가 크게 향상됩니다. Docker를 CI 도구와 결합하여 사용하면 능률적 인 배포를위한 업계 표준이되었습니다.

그렇지 않으면 : 긴 배포 -> 생산 중단 시간 및 인간 관련 오류 -> 팀 구성이 불안정하고 배포가 어려움 -> 배포 및 기능이 적음

19. 각 배포에서 NPM 버전을 충돌시킵니다.
TL : DR : 새 버전이 출시 될 때마다 package.json 버전 속성을 늘려서 프로덕션 환경에서 어떤 버전이 배포되는지 명확하게 알 수 있습니다. 다른 서버가 다른 버전을 보유 할 수있는 MicroService 환경에서는 더욱 그렇습니다. "npm version"명령은 자동으로이를 수행 할 수 있습니다.

그렇지 않은 경우 : 개발자는 배포 된 시스템 내에서 프로덕션 버그 (여러 서비스의 여러 버전)를 사냥하려고 시도합니다.

20. Nodejs의 LTS 릴리스 사용
TL : DR : Node.js의 LTS 버전을 사용하여 중요한 버그 수정, 보안 업데이트 및 성능 향상을 받으십시오.

그렇지 않으면 : 새로 발견 된 버그 나 취약점이 프로덕션 환경에서 실행되는 응용 프로그램을 악용하는 데 사용될 수 있으며 응용 프로그램이 다양한 모듈에 의해 지원되지 않을 수 있으며 유지 관리가 어려울 수 있습니다

21. 진짜 카오스에 대한 모니터링을 확인하십시오 (원숭이 사용)
TL : DR : 인생은 예상치 못한 일이 생산 과정에서 일어날 것임을 말해줍니다. 몇 가지 이름을 지정하면 서버가 종료되고 SSL 인증서 유효성이 취소 될 수 있으며 이벤트 루프가 차단되고 DNS 레코드가 변경되어 계속 될 수 있습니다. 이것은 희귀 한 조건처럼 들리지만 일어난 일이며 대개 폭풍과 같은 큰 영향을줍니다. 이러한 혼란스러운 조건을 시뮬레이션하지 않고 응용 프로그램이 생존하거나 적어도 발생 상황을보고 할 수 있는지 확인하지 않고는이 위험을 진정으로 줄일 수있는 방법이 없습니다. Netflix 카오스 - 원숭이 는 혼돈 생성을위한 가장 유명한 도구입니다. 내 Nodejs 카오스 원숭이 는 노드 및 프로세스 관련 혼돈에 초점을 맞추고 있습니다.

그렇지 않으면 : 여기에 탈출 없음, Murphy의 법칙은 자비없이 당신의 작품을 치게 될 것입니다.

22. 계속 지켜봐주십시오. 더 많은 소식이 곧 있습니다.
TL : DR : 사후 디버깅, libuv 스레드 풀 조정, 생산 연기 테스트 작성 등과 같은 다른 제작 모범 사례에 대해 곧이 글을 작성하려고합니다. 업데이트 상태를 유지하고 싶습니까? 내 트위터 또는 Facebook 페이지를 팔로우하십시오.

